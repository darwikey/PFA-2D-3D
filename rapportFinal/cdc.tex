retour sur la rédaction du cahier des charges
aide du client (cours du début pour ce qu'il attendait comme contenu)
suivi hebdomadaire pour contrôler l'avancée et nous orienter pour un cahier des charges comme il l'attendait
méthode de travail, recherches, prototypes

\paragraph{}
        Dans le cadre du projet PFA, la première partie consistait à rédiger un cahier des charges fonctionnel pour définir l'ensemble des besoins du futur logiciel.

\paragraph{}
        Lors de notre premier rendez-vous, notre client a d'ores et déjà défini le format qu'il souhaitait pour le cahier des charges, et le contenu qui était essentiel pour lui. Il fallait ainsi présenter le domaine d'études et les connaissances actuelles sur des algorithmes de création d'anaglyphes, d'autostéréogrammes ou de folioscopes. Ensuite, le sujet était à redéfinir précisément, puis les besoins fonctionnels et non fonctionnels demandés par les clients pour ce logiciel, ainsi que les contraintes engendrées par ceux-ci. Enfin, il fallait présenter des prototypes permettant de répondre aux différents besoins ennoncés, quelques interfaces graphiques pour simuler l'utilisation du logiciel, et surtout réfléchir à l'architecture future du projet.

\paragraph{}
        La rédaction des parties Domaine et Etat de l'existant aura demandé de nombreuses recherches, notamment pour trouver des articles présentant des algorithmes de création d'anaglyphes et d'autostéréogrammes. 
L'étude du domaine aura permis de se familiariser avec le vocabulaire de la synthèse d'image et avec les différents rendus souhaités par nos clients. Des notions telles que la scène, la caméra, ainsi que la compréhension du fonctionnement des anaglyphes et des autostéréogrammes, auront ainsi permis une meilleure immersion dans notre projet.
Les algorithmes relatifs aux anaglyphes concernent principalement le traitement des couleurs pour qu'aucun artefact n'apparaisse au moment de la visualisation finale. Pour les autostéréogrammes, le traitement d'une carte des profondeurs permet d'obtenir une image qui, lorsque l'on sait l'observer, fait apparaître un relief. Enfin, il n'existe pas d'algorithme particulier pour la génération de folioscopes. Seule une série de prises de vue d'une scène avec des angles d'observation proches peuvent permettre, si elles sont visualisées les unes à la suite des autres et suffisamment rapidement, de pouvoir imaginer un mouvement, et ainsi un relief.

\paragraph{}
        Les besoins fonctionnels et non fonctionnels d'un projet doivent impérativement être ciblés durant la phase de cahier des charges, car c'est grâce à eux que le contrat passé entre les clients et l'équipe de programmeurs pourra être exhaustif et protéger les deux parties contre d'éventuelles envies de modification au cours de la phase de réalisation. 
Pour un tel logiciel, les besoins fonctionnels s'apparentent bien souvent à de futures fonctionnalités du logiciel, tel que la création d'une scène, sa manipulation, et les prises de vue pour obtenir les rendus demandés dans le sujet. 
Toutefois, les besoins non fonctionnels, même s'ils peuvent être clairement énoncés par le client, sont bien souvent implicites et doivent être déterminés en fonction du discours tenu. Pour un logiciel de synthèse d'images, la fluidité d'affichage est bien souvent un besoin essentiel, car l'utilisateur s'attend à une certaine rapidité du logiciel lors de la manipulation de la scène et de la génération de rendus. Mais d'autres besoins, à savoir la portabilité du logiciel et sa maintenabilité, ont également été exprimés par les clients et ont été considérés comme essentiels pour ce projet. En effet, l'utilisaton de ce logiciel, au moins sous les systèmes d'exploitation Linux et Windows, était importante pour pouvoir travailler sur différentes machines dans leur travail. De plus, un tel logiciel pouvait être amené à être amélioré ou réutilisé en partie dans de futurs projets, et c'est pourquoi il devait être facilement maintenable.
Ces besoins ont apportés des contraintes quand à la réalisation du logiciel, par exemples sur les langages et les bibliothèques utilisées. Les choix ainsi effectués pour permettre de tenir ces contraintes seront détaillées par la suite.

\paragraph{}
Pour s'assurer de la faisabilité des besoins fonctionnels et non fonctionnels du projet, deux prototypes ont été mis en place : un prototype de fichier XML pour réfléchir au format de sauvegarde et de chargement de la scène, et un prototype de scène en trois dimensions pour tester les fonctionnalités possibles avec le langage C++ et les bibliothèques que nous souhaitions utiliser : Qt et OpenGL pour Qt. Ce prototype aura également permis de s'assurer de la portabilité de ces bibliothèques, ainsi que de la fluidité potentielle du futur logiciel.
Le prototype XML aura permis de réfléchir aux informations importantes à stocker pour pouvoir recréer une scène à l'identique. Tout d'abord, les informations relatives aux objets doivent être stockées, telles que leur nom et leur fichier d'origine, mais également leur position, leur orientation et leur échelle. Les informations relatives à la caméra sont également essentielles pour retrouver l'angle d'observation de la scène, et les informations à stocker sont sa position, son orientation, ou encore son angle de vue. Le prototype d'origine du fichier XML est donné dans la partie Annexe du Cahier des Charges, lui-même présent en Annexe de ce rapport. Un exemple de fichier XML obtenu à partir de ce prototype est également donné en Annexe.
Le prototype logiciel réalisé en C++ a permis de mettre en place une première version de scène contenant un objet obtenu grâce à une première version de parseur de fichiers d'extension PLY. La manipulation de cette scène a permis de tester quelques valeurs de fluidité pour pouvoir se rendre compter des capacités d'affichage des bibliothèques utilisées, qui semblaient satisfaire nos attentes. De plus, le test du prototype sur des machines Windows et Linux ont montré la portabilité des bibliothèques, même si les versions de shaders utilisées auront posé problème par la suite comme il est détaillé dans la partie suivante de ce rapport. Un exemple d'affichage du prototype initial est donné dans la [FIGURE N°], et des exemples de l'affichage final seront donnés plus tard dans ce rapport.

\paragraph{}
Pour satisfaire le besoin d'extensibilité de notre projet, nous avons mis en place une architecture modulaire pour permettre à notre logiciel d'être modifié de façon simple. L'architecture principale est donné dans la [FIGURE].

//figure

Les besoins en modularité de notre projet se reflète particulièrement dans le paquetage Création de l'architecture, qui permet la création des différents rendus que le logiciel permet d'obtenir. L'architecture de ce paquetage est donné dans la [FIGURE N°]

//figure

L'extensibilité de cette architecture se traduit principalement par l'utilisation d'interfaces à différents niveaux. Tout d'abord, le Creator, point d'entrée du paquetage, a pour attribut une première interface Creation qui peut devenir n'importe lequel des rendus souhaité par l'utilisateur. Il peut donc aussi bien devenir un anaglyphe qu'un autostéréogramme. Toutefois, pour permettre l'utilisation de divers algorithmes pour réaliser un même rendu, les classes des rendus sont également des interfaces dont héritent les classes réellement instanciables qui correspondent chacune à un algorithme. On aura donc par exemple AnaglyphAlgorithm1 ou encore DepthMapAlgorithm2.
