\paragraph{}
        Pour la réalisation du projet, nos clients nous proposaient des langages comme le C, le C++ ou encore le Python. Le C++ nous est apparu comme le choix le plus judicieux pour notre logiciel. En effet nous voulions un langage orienté objet, pour avoir du code lisible et une architecture claire, et un langage qui soit rapide pour pouvoir effectuer des rendus en un temps raisonnable.
        
	L'utilisation du C++11 nous permet d'utiliser entre autres : les std::unique\_ptr pour limiter les risques de fuite de mémoire ou les lambda expressions pour garder en mémoire les actions de l'utilisateur.

    Comme nous l'avons exprimé plus haut, l'un des besoins non fonctionnels primordiaux de notre projet est la maintenabilité du code. Pour celà, il nous fallait choisir des outils et des bibliothèques qui étaient destinées à perdurer le plus longtemps possible.
    
    L'utilisation de Qt et d'OpenGL est assez répandue pour des logiciels de visualisation et de manipulation en trois dimensions. De plus Qt est très complet et propose un vaste choix de modules qui permettent de traiter un ensemble très variable de tâches (par exemple l'analyse de fichiers XML ou la gestion d'évènement). Comme ces bibliothèques sont parfaitement portables, elles convenaient parfaitement à l'implémentation que nous souhaitions réaliser.
    
    La version 5 de Qt est la plus récente actuellement, mais malgré sa jeunesse elle est devenu au fil des modifications suffisament stable pour pouvoir être utilisée sans problème, et elle dispose d'une communauté Internet active prête à aider en cas de difficultés de code. De plus, cette bibliothèque utilise la version ES 2.0 de OpenGL, qui est une version non seulement qui utilise des shaders, mais également qui peut être utilisée pour de la programmation d'applications mobile par exemple. C'est donc pour cette variété, cette communauté, cette maintenabilité et cette extensibilité que nous avons choisi d'utiliser ces bibliothèques et ces versions.

    Pour la compilation du projet et des bibliothèques, nous avons choisi d'utiliser CMake, qui est répandu et portable. Nous aurions pu choisir également QMake, mais celui-ci dépandant trop fortement de QtCreator, nous avons préféré ne pas l'utiliser.
